\chapter{Maps}\label{chapter:maps}


We've used \Sage{} to define vector spaces.
Next we explore the functions between vector spaces.

As we've done earlier, although we think of the vector spaces 
as having real number scalars, here
we shall define matrices with rational number
entries, just because they illustrate the points perfectly well
and are more pleasant to work with.
  

%========================================
\section{Left/right} \label{sec:leftright}
\Sage{} represents linear
maps differently than the book does.
An example explains it best.
We will represent applying a linear map 
to a member of a vector space.
% $t(\vec{v})$.
Consider
this function $\map{t}{\Re^2}{\Re^3}$ and this vector from the domain.
\begin{equation*}
  t(\colvec{a \\ b})
  =\colvec{a+b \\ a-b \\ b}
  \qquad
  \vec{v}=\colvec{1 \\ 3}
\end{equation*}
The map gives this output.
\begin{equation*}
  t(\colvec{1 \\ 3})
  =\colvec{4 \\ -2 \\ 3}
\end{equation*}
To represent that, we fix bases. 
We can use the canonical bases $\stdbasis_2\subset\Re^2$ 
and~$\stdbasis_3\subset\Re^3$.
With respect to these we get  
a matrix~$T=\rep{t}{\stdbasis_2,\stdbasis_3}$ representing the map 
and a vector $\vec{w}=\rep{\vec{v}}{\stdbasis_2}$ representing
the domain element.

The book represents 
the map application~$t(\vec{v})$ 
with this matrix-vector product~$T\vec{w}$.
\begin{equation*}
  \begin{mat}
    1 &1 \\
    1 &-1 \\
    0 &1
  \end{mat}
  \colvec{1 \\ 3}
  =
  \colvec{4 \\ -2 \\ 3}
\end{equation*}
That is, the book is write-right:~its notation puts the vector on the right 
of the matrix.
However, many authors instead choose to
use a row vector and multiply the matrix from the left.
\Sage{} is in this camp and
represents the same map application in this way.
\begin{equation*}
  \rowvec{1 &3}
  \begin{mat}
    1 &1  &0 \\
    1 &-1 &1
  \end{mat}
  =
  \rowvec{4 &-2 &3}
\end{equation*}
Notice that the matrices and vectors are transposes of each other.

Obviously the difference is cosmetic.
Rather than quarrel with the tool, in this manual we will do it
\Sage's way.
The translation is that, compared to the book's~$T\vec{w}$,
\Sage{} prefers~$\trans{\vec{w}}\;\trans{T}$.



  

%========================================
\section{Defining}
We will see two different ways to define a linear transformation.

\subsection{Symbolically}
We first define a map that takes two inputs and returns three outputs.
\begin{sagecommandline}
sage: a, b = var('a, b')   
sage: T_symbolic(a, b) = [a+b, a-b, b]         
sage: T_symbolic       
\end{sagecommandline}
We have not yet defined a domain and codomain 
so this not a function\Dash instead it is a prototype for a function.
Make an instance of a function by applying $T_{\textit{symbolic}}$ on a 
particular domain and codomain.  % ;s,7,68,62;s,8,70,62]
\begin{sagecommandline} 
sage: T = linear_transformation(QQ^2, QQ^3, T_symbolic)
sage: T                                              
\end{sagecommandline}
\noindent Note again the left/right issue as discussed above:~\Sage's matrix is 
the transpose of the matrix that the book would use.

Evaluating this function on a member of the domain gives a member
of the codomain. 
\begin{sagecommandline}
sage: v = vector(QQ, [1, 3])  
sage: v
sage: T(v)
\end{sagecommandline}

If the vector isn't a member of the domain
\begin{lstlisting}
sage: v1 = vector(QQ, [1,2,3,4])
sage: T(v1)
\end{lstlisting}
then \Sage{} gives an error message.
This is its final line.
\begin{lstlisting}
TypeError: (1, 2, 3, 4) fails to convert into the map's domain Vector space 
  of dimension 2 over Rational Field, but a `pushforward` method is not 
  properly implemented
\end{lstlisting}

\Sage{} can find the null space 
and range space, using the equivalent 
terms \textit{kernel} and \textit{image}.
\begin{sagecommandline}
sage: T.kernel()                                       
sage: T.image()                                        
\end{sagecommandline}
The null space is the trivial subspace of the domain,
$\set{\zero}$, the $0$-dimensional
subspace, so \Sage{} reports that its basis is empty.
Therefore the map that the matrix represents, $t$, is one-to-one.

The range space is $2$-dimensional. 
Since the codomain is $3$-dimensional, the map~$t$ is not onto.
Note also that this fits with the theorem that
the dimension of the null space plus the dimension of the 
range space equals to the dimension of the domain.

For contrast consider a map that is not one-to-one.
\begin{sagecommandline}
sage: S_symbolic(a, b) = [a+2*b, a+2*b]
sage: S_symbolic
sage: S = linear_transformation(QQ^2, QQ^2, S_symbolic)
sage: S
sage: v = vector(QQ, [1, 3])  
sage: S(v)
\end{sagecommandline}
This map is not one-to-one since we can get two inputs
to map to the same output, 
as here.  
\begin{sagecommandline}
sage: S_symbolic(a, b) = [a+2*b, a+2*b]
sage: S = linear_transformation(QQ^2, QQ^2, S_symbolic)
sage: S(vector(QQ, [2, 0]))
sage: S(vector(QQ, [0, 1]))
\end{sagecommandline}
\noindent
Another way to tell that the map is not one-to-one is to look at the 
null space.
\begin{sagecommandline}
sage: S.kernel()
sage: S.image()
\end{sagecommandline}
The null space has nonzero dimension, namely it 
has dimension~$1$,
so \Sage{} agrees that the map is not one-to-one.

Without looking at the range space we know that its dimension must be~$1$ 
because the dimensions of the null and range spaces add to
the dimension of the domain.
\Sage{} confirms that.



\subsection{Via matrices}
The other way that we can define a linear map is by specifying 
the matrix representing its action.
\begin{sagecommandline}
sage: M = matrix(QQ, [[1, 2], [3, 4], [5, 6]])
sage: M
sage: m = linear_transformation(M)
sage: m  
\end{sagecommandline}
Again, \Sage{} prefers the 
representation where the vector multiplies
from the left.
\begin{sagecommandline}
sage: M = matrix(QQ, [[1, 2], [3, 4], [5, 6]])
sage: m = linear_transformation(M)
sage: v = vector(QQ, [7, 8, 9])
sage: v
sage: m(v)  
\end{sagecommandline}
\Sage{} has done this calculation.
\begin{equation*}
  \colvec{7 &8 &9}
  \begin{mat}
    1 &2 \\
    3 &4 \\
    5 &6
  \end{mat}
  =\colvec{76 &100}
\end{equation*}

If you have a matrix intended for a vector-on-the-right
calculation (as in the book) then \Sage{} can make the necessary adjustment.
\begin{sagecommandline}
sage: N = matrix(QQ, [[1, 3, 5], [2, 4, 6]])
sage: n = linear_transformation(N, side='right')
sage: n
sage: v = vector(QQ, [7, 8, 9])
sage: v
sage: n(v)  
\end{sagecommandline}
\noindent Although we gave it a \inlinecode{side='right'} option, 
the matrix that \Sage{} shows by default is for 
\inlinecode{side='left'}.

Despite that we specified them differently, 
these two transformations are the same.
\begin{sagecommandline}
sage: M = matrix(QQ, [[1, 2], [3, 4], [5, 6]])
sage: m = linear_transformation(M)
sage: N = matrix(QQ, [[1, 3, 5], [2, 4, 6]])
sage: n = linear_transformation(N, side='right')
sage: m == n  
\end{sagecommandline}

We can ask the same questions of linear transformations created from
matrices that we asked of linear transformations created from functions.
\begin{sagecommandline}
sage: M = matrix(QQ, [[1, 2], [3, 4], [5, 6]])
sage: m = linear_transformation(M)
sage: m.kernel() 
\end{sagecommandline}

The null space of them map $m$ is not the trivial subspace of $\Re^3$ 
and so this function is not one-to-one.
The domain has dimension~$3$ and the null space has dimension~$1$ 
and so the
range space is a dimension~$2$ subspace of $\Re^2$.
\begin{sagecommandline} 
sage: m.image()
\end{sagecommandline}

\Sage{} lets us have the matrix represent a transformation involving 
spaces with nonstandard bases.
(As discussed above, although we are thinking of the vector spaces
as having scalars that are real numbers, we are telling \Sage{} that
the scalars are rational, which explains the \inlinecode{QQ}'s 
in this example.)
\begin{sagecommandline}
sage: M = matrix(QQ, [[1, 2], [3, 4]])
sage: delta_1 = vector(QQ, [1, -1])
sage: delta_2 = vector(QQ, [1, 1])
sage: domain_basis = [delta_1, delta_2]
sage: domain_basis
sage: D = (QQ^2).subspace_with_basis(domain_basis)
sage: gamma_1 = vector(QQ, [2, 0])
sage: gamma_2 = vector(QQ, [0, 3])
sage: codomain_basis = [gamma_1, gamma_2]
sage: codomain_basis
sage: C = (QQ^2).subspace_with_basis(codomain_basis)
sage: m = linear_transformation(D, C, M)
sage: m
sage: m(vector(QQ, [1, 0]))
\end{sagecommandline}
\noindent
\Sage{} has calculated that
\begin{equation*}
  \colvec{1 \\ 0}=(1/2)\colvec{1 \\ -1}+(1/2)\colvec{1 \\ 1}
  \quad\text{so}\quad
  \rep{\colvec{1 \\ 0}}{\textit{domain\_basis}}=\colvec{1/2 \\ 1/2} 
\end{equation*}
and then computed this.
\begin{equation*}
  \rep{m(\vec{v})}{\textit{codomain\_basis}}
  =
  \rowvec{1/2 &1/2}
  \begin{mat}
    1 &2 \\
    3 &4
  \end{mat}
  =
  \rowvec{2 &3}
  \quad\text{so}\quad
  m(\vec{v})=2\colvec{2 \\ 0}+3\colvec{0 \\ 3}
  =\colvec{4 \\ 9}
\end{equation*}





%========================================
\section{Operations}

Fix some vector space domain~$D$ and codomain~$C$ and consider the
set of all linear transformations between them. 
This collection has some natural operations, including
addition and scalar multiplication.
\Sage{} can work with those operations.

\subsection{Addition}
% First create two functions. 
% \begin{sagecommandline}
% sage: f_symbolic(x,y) = [x-y, x+2*y, 3*x]  
% sage: g_symbolic(x,y) = [y, 2*x-y, y]  
% \end{sagecommandline}
% We can add these two and with that new function make a linear 
% transformation.
% \begin{sagecommandline}
% sage: f_symbolic(x,y) = [x-y, x+2*y, 3*x]  
% sage: g_symbolic(x,y) = [y, 2*x-y, y]  
% sage: f_symbolic+g_symbolic
% sage: h = linear_transformation(RR^2, RR^3, f_symbolic+g_symbolic)
% sage: h
% \end{sagecommandline}
% We could instead make two linear transformations and then add.
% \begin{sagecommandline}
% sage: f_symbolic(x,y) = [x-y, x+2*y, 3*x]  
% sage: g_symbolic(x,y) = [y, 2*x-y, y]  
% sage: f = linear_transformation(RR^2, RR^3, f_symbolic)
% sage: g = linear_transformation(RR^2, RR^3, g_symbolic)
% sage: h = f + g
% sage: h
% \end{sagecommandline}
Recall that matrix addition is defined so that the representation of
the sum of two linear transformations is the matrix sum of the representatives.
\Sage{} can illustrate.
\begin{sagecommandline}
sage: M = matrix(QQ, [[1, 2], [3, 4]])
sage: m = linear_transformation(QQ^2, QQ^2, M)
sage: m
sage: N = matrix(QQ, [[5, -1], [0, 7]])
sage: n = linear_transformation(QQ^2, QQ^2, N)
sage: n
sage: m+n
sage: M+N
\end{sagecommandline}
\noindent Similarly, linear map scalar multiplication is reflected in 
matrix scalar multiplication.
\begin{sagecommandline}
sage: M = matrix(QQ, [[1, 2], [3, 4]])
sage: m = linear_transformation(QQ^2, QQ^2, M)
sage: m*3
sage: M*3  
\end{sagecommandline}



\subsection{Composition}
The composition of linear maps gives rise to matrix multiplication.
\Sage{} uses the \inlinecode{*}~symbol to denote composition of linear maps.
\begin{sagecommandline}
sage: M = matrix(QQ, [[1, 2], [3, 4]])
sage: m = linear_transformation(QQ^2, QQ^2, M)
sage: m
sage: N = matrix(QQ, [[5, -1], [0, 7]])
sage: n = linear_transformation(QQ^2, QQ^2, N)
sage: n
sage: m*n
\end{sagecommandline}

\textit{Note:} there is a left/right issue here.
As the book emphasizes, matrix multiplication is about 
representing the composition of the maps.
The composition $\composed{m}{n}$ is the map $\vec{v}\mapsto m(n(\vec{v}))$, 
with $n$ applied first. 
We can walk through the calculation of applying $n$ first and then~$m$
\begin{equation*}
  \colvec{1 \\ 2}
   \mapsunder{n}
  \colvec{5 \\ 13}
   \mapsunder{m}
  \colvec{44 \\ 62}
\end{equation*}
via these matrix multiplications.
\begin{equation*}
  \rowvec{1 &2}
  \begin{mat}
    5 &-1 \\ 
    0 &7
  \end{mat}
  =\rowvec{5 &13}
  \quad\text{followed by}\quad
  \rowvec{5 &13}
  \begin{mat}
    1 &2 \\ 
    3 &4
  \end{mat}
  =\rowvec{44 &62}
\end{equation*}
\Sage{} prefers the representing vector on the left so to be the 
first matrix used, $N$ must come left-most: $\composed{m}{n}$ is represented 
by $NM$.
Here \Sage{} does the map application.
\begin{sagecommandline}
sage: M = matrix(QQ, [[1, 2], [3, 4]])
sage: N = matrix(QQ, [[5, -1], [0, 7]])
sage: M*N
sage: N*M
sage: m = linear_transformation(QQ^2, QQ^2, M)
sage: n = linear_transformation(QQ^2, QQ^2, N)
sage: t = m*n
sage: t
sage: v = vector(QQ, [1, 2])
sage: t(v)
\end{sagecommandline}
Again, as this shows,
to represent $\composed{m}{n}$ using
\Sage's default vector-on-the-left form, 
you must take the matrix multiplication in the $NM$ order. 


% By the way, you must be careful about how you write that calculation.
% \begin{sagecommandline}
% sage: M = matrix(QQ, [[1, 2], [3, 4]])
% sage: m = linear_transformation(QQ^2, QQ^2, M)
% sage: N = matrix(QQ, [[5, -1], [0, 7]])
% sage: n = linear_transformation(QQ^2, QQ^2, N)
% sage: v = vector(QQ, [1, 2])
% sage: m*n(v)
% \end{sagecommandline}
% This gives an error because \Sage{} tries to compose the function~$m$ with the
% vector~$n(\vec{v})$.
% Instead you need some parentheses.
% \begin{sagecommandline}
% sage: M = matrix(QQ, [[1, 2], [3, 4]])
% sage: m = linear_transformation(QQ^2, QQ^2, M)
% sage: N = matrix(QQ, [[5, -1], [0, 7]])
% sage: n = linear_transformation(QQ^2, QQ^2, N)
% sage: v = vector(QQ, [1, 2])
% sage: (m*n)(v)
% \end{sagecommandline}






\endinput


TODO:
