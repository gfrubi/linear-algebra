\chapter{Maps}\label{chapter:maps}


We've used \Sage{} to define vector spaces.
Next we explore functions between vector spaces.

As we've done earlier, although we think of the vector spaces 
as having real number scalars, here
we shall define matrices with rational number
entries, just because they illustrate the points perfectly well
and are more pleasant to work with.
  

%========================================
\section{Linear functions} \label{sec:linearfunctions}
\Sage{} can work with functions.
\begin{equation*}
  t(\colvec{a \\ b})
  =\colvec{a+2b \\ a+2b}
\end{equation*}
\begin{sagecommandline}
sage: a, b = var('a, b')   
sage: t_symbolic(a, b) = [a+2*b, a+2*b]         
sage: t_symbolic       
sage: t_symbolic(1,3)       
\end{sagecommandline}

\Sage{} can add add two functions or find a scalar multiple of a function.
\begin{sagecommandline}
sage: t_symbolic(a, b) = [a+2*b, a+2*b]         
sage: f_symbolic = 3 * t_symbolic
sage: f_symbolic
sage: f_symbolic(4, 2)
sage: s_symbolic(a,b) = [a+b, a-b]
sage: g_symbolic = s_symbolic + t_symbolic
sage: g_symbolic
sage: g_symbolic(1, 5) 
\end{sagecommandline}
\Sage{} can also find the composition of two functions.
\begin{sagecommandline}
sage: s_symbolic * f_symbolic
sage: s_symbolic * f_symbolic (1,2)
\end{sagecommandline}

We used the oddball names, 
\inlinecode{t_symbolic}, \inlinecode{s_symbolic}, etc.,
because these are not functions in that we have not described a domain
and codomain; rather they are prototypes for functions.  
We can use one to produce a linear function $\map{t}{\Re^2}{\Re^3}$.
\begin{sagecommandline} 
sage: a, b = var('a, b')   
sage: t_symbolic(a, b) = [a+2*b, a+2*b]         
sage: t = linear_transformation(QQ^2, QQ^2, t_symbolic)
\end{sagecommandline}
(As discussed earlier, although we are thinking of the vector spaces
as having real number scalars, we tell \Sage{} that
the scalars are rational because they make easier to understand examples.
Note also that \Sage{} uses `linear transformation' for any linear map,
while the book only uses that term for maps where the domain and codomain
are equal.)

With the transformation~$t$ we expect this
\begin{equation*}
  t(\colvec{1 \\ 3})
  =\colvec{7 \\ 7}
\end{equation*}
and \Sage{} delivers.
\begin{sagecommandline}
sage: v = vector(QQ, [1, 3])
sage: t(v)
\end{sagecommandline}



%========================================
\section{Left/right} \label{sec:leftright}
By default, \Sage{} represents linear
maps differently than the book does.
An example explains it best.
Consider again the transformation $\map{t}{\Re^2}{\Re^2}$.
\begin{equation*}
  t(\colvec{a \\ b})
  =\colvec{a+2b \\ a+2b}
\end{equation*}
To represent it with respect to $B,D\subset\Re^2$, 
we can use the canonical bases $B=\stdbasis_2$, $D=\stdbasis_2$.
We find the effect of~$t$ on the elements of~$B$ and represent the
results with respect to~$D$.
\begin{equation*}
  \colvec{1 \\ 0}\mapsunder{t}\colvec{1 \\ 1}
  \text{\ gives\ }
  \rep{\colvec{1 \\ 1}}{D}=\colvec{1 \\ 1}
  \qquad
  \colvec{0 \\ 1}\mapsunder{t}\colvec{2 \\ 2}
  \text{\ gives\ }
  \rep{\colvec{2 \\ 2}}{D}=\colvec{2 \\ 2}
\end{equation*}
Thus the book gets this matrix
\begin{equation*}
  % \hspace*{3em}
  \rep{t}{B,D}=
  \begin{mat}
    1  &2  \\
    1  &2
  \end{mat}
\end{equation*}
but \Sage{} shows a different one.
\begin{sagecommandline}
sage: t_symbolic(a, b) = [a+2*b, a+2*b]         
sage: t = linear_transformation(QQ^2, QQ^2, t_symbolic)  # see discussion of 'side' below
sage: t
\end{sagecommandline}
What's happening?

Remember that the point of a matrix representation is to
use the representation of $t$ and $\vec{v}$ to compute
the representation of $h(\vec{v})$.
The book has
\begin{equation*}
  \rep{t}{B,D}\,\rep{\vec{v}}{B}=\rep{t(\vec{v})}{D}
\end{equation*}
with the column vector on the right of the matrix.
\Sage{}, on the other hand, by default has the vector on the left, as a 
row vector.
The translation is that, compared to the book's~$T\vec{v}$,
\Sage{}'s default is:~$\trans{\vec{v}}\;\trans{T}$.
That's why above \Sage{}'s matrix is the transpose of the book's matrix.

Obviously the difference is cosmetic.
To get \Sage{} to conform to the book's convention we need to do two 
things.
We need to define the linear transformation using the
option \inlinecode{side='right'}, and when we show the
matrix we need to use the same option.
This demonstrates.
\begin{sagecommandline}
sage: t_symbolic(a, b) = [a+2*b, a+2*b]         
sage: t = linear_transformation(QQ^2, QQ^2, t_symbolic, side='right')  
sage: t.matrix(side='right')
\end{sagecommandline}


  

%========================================
\section{Defining}
We can define a linear map in a number of ways.
We'll describe two of them here.

\subsection{Symbolically}
We've already been introduced to defining a map by formula.
\begin{sagecommandline}
sage: a, b = var('a, b')   
sage: h_symbolic(a, b) = [a+b, a-b, b]         
sage: h_symbolic       
sage: h = linear_transformation(QQ^2, QQ^3, h_symbolic, side='right')
sage: h.matrix(side='right') 
\end{sagecommandline}
Evaluating this function on a member of the domain gives a member
of the codomain. 
\begin{sagecommandline}
sage: v = vector(QQ, [1, 3])  
sage: h(v)
\end{sagecommandline}

If the vector isn't a member of the domain
\begin{lstlisting}
sage: v1 = vector(QQ, [1,2,3,4])
sage: h(v1)
\end{lstlisting}
then \Sage{} gives a long traceback error message, but as usual the final line 
is the most informative since it contains:
\inlinecode{Type Error:(1, 2, 3, 4) fails to convert into the map's domain}.

\Sage{} can find the null space 
and range space, using the equivalent 
terms \textit{kernel} and \textit{image}.
\begin{sagecommandline}
sage: h.kernel()                                       
sage: h.image()                                        
\end{sagecommandline}
\Sage{} has found that 
the null space $\nullspace{h}$ is the trivial subspace of the domain,
$\set{\zero}$.
This is a $0$-dimensional
subspace so \Sage{} reports that its basis is empty.
\Sage{} found that the range space $\rangespace{h}$ is $2$-dimensional. 

Because the null space is trivial, the map is one-to-one. 
Because the range space is $2$-dimensional but 
the codomain is $3$-dimensional, the map~$t$ is not onto.
Note also that \Sage's findings fit with the theorem that
the dimension of the null space plus the dimension of the 
range space equals to the dimension of the domain.

For contrast consider a map that is not one-to-one.
\begin{sagecommandline}
sage: t_symbolic(a, b) = [a+2*b, a+2*b]
sage: t_symbolic
sage: t = linear_transformation(QQ^2, QQ^2, t_symbolic, side='right')
\end{sagecommandline}
This map is not one-to-one since we can get two inputs
to map to the same output, 
as here.  
\begin{sagecommandline}
sage: t(vector(QQ, [2, 0]))
sage: t(vector(QQ, [0, 1]))
\end{sagecommandline}
\noindent
Another way to tell that the map is not one-to-one is compute that the 
$\nullspace{t}$ is $0$-dimensional.
\begin{sagecommandline}
sage: t.kernel()
\end{sagecommandline}

Before looking at the range space, we know that its dimension must be~$1$ 
because the dimensions of the null space and
range space add to the dimension of the domain.
\Sage{} confirms.
\begin{sagecommandline}
sage: t.image()
\end{sagecommandline}



\subsection{Via matrices}
The other way that we can define a linear map is with
a matrix.
\begin{sagecommandline}
sage: M = matrix(QQ, [[1, 2], [3, 4], [5, 6]])
sage: M
sage: m = linear_transformation(M, side='right')
\end{sagecommandline}
Because the matrix has rational entries, \Sage{} takes the
domain and codomain to be $\Q^2$ and $\Q^3$.
\begin{sagecommandline}
sage: m     # does not conform to the book
\end{sagecommandline}
Note again that by default \Sage{} prefers the 
representation where the vector multiplies
from the left so we specify \inlinecode{side='right'}.
Also, although we defined the linear map with
\mbox{\inlinecode{side='right'},} 
the matrix that \Sage{} shows by default is for 
\inlinecode{side='left'}.
We must ask for the representation fitting the text.
\begin{sagecommandline}
sage: m.matrix(side='right')
\end{sagecommandline}

When defined with a matrix, the transformation acts as expected.
\begin{sagecommandline}
sage: m = linear_transformation(M, side='right')
sage: v = vector(QQ, [7, 8])
sage: v
sage: m(v)  
\end{sagecommandline}
Leaving \inlinecode{side='right'} out of the definition of the
linear map and then multiplying 
by the two-element vector would give an error message
complaining that the vector is not in the map's 
$3$-dimensional domain.

Although these maps are defined in two ways, 
\Sage{} can tell whether they are the same.
\begin{sagecommandline}
sage: M = matrix(QQ, [[1, 2], [3, 4], [5, 6]])
sage: m = linear_transformation(M, side='right')
sage: n_symbolic(a, b) = [a+2*b, 3*a+4*b, 5*a+6*b]
sage: n = linear_transformation(QQ^2, QQ^3, n_symbolic, side='right')
sage: m == n  
\end{sagecommandline}
And we can ask the same questions of linear maps created from
matrices that we asked of linear maps created from functions.
\begin{sagecommandline}
sage: M = matrix(QQ, [[1, 2], [3, 4], [5, 6]])
sage: m = linear_transformation(M, side='right')
sage: m.kernel() 
\end{sagecommandline}

\Sage{} lets us define a map by starting with a matrix representing that map 
with respect to nonstandard bases.
\begin{sagecommandline}
sage: M = matrix(QQ, [[1, 2], [3, 4]])
sage: delta_1 = vector(QQ, [1, -1])
sage: delta_2 = vector(QQ, [1, 1])
sage: domain_basis = [delta_1, delta_2]
sage: D = (QQ^2).subspace_with_basis(domain_basis)
sage: gamma_1 = vector(QQ, [2, 0])
sage: gamma_2 = vector(QQ, [0, 3])
sage: codomain_basis = [gamma_1, gamma_2]
sage: C = (QQ^2).subspace_with_basis(codomain_basis)
sage: m = linear_transformation(D, C, M, side='right')
sage: m.matrix(side='right')
sage: m(vector(QQ, [1, 0]))
\end{sagecommandline}
\Sage{} has calculated that
\begin{equation*}
  \colvec{1 \\ 0}=(1/2)\colvec{1 \\ -1}+(1/2)\colvec{1 \\ 1}
  \quad\text{so}\quad
  \rep{\colvec{1 \\ 0}}{\textit{dom\_basis}}=\colvec{1/2 \\ 1/2} 
\end{equation*}
and then computed this.
\begin{equation*}
  \begin{mat}
    1 &2 \\
    3 &4
  \end{mat}
  \colvec{1/2 \\ 1/2}
  =
  \colvec{3/2 \\ 7/2}
  =
  \rep{m(\vec{v})}{\textit{codom\_basis}}
  \quad\text{so}\quad
  m(\vec{v})=(3/2)\colvec{2 \\ 0}+(7/2)\colvec{0 \\ 3}
  =\colvec{3 \\ 21/2}
\end{equation*}





%========================================
\section{Operations}

Fix some vector space domain~$D$ and codomain~$C$ and consider the
set of all linear transformations between them. 
This collection has some natural operations, including
addition and scalar multiplication.
Earlier we saw that \Sage{} can work with these operations, as well
as composition, and we now close by showing the effect they have
on the representations.


\subsection{Addition and scalar multiplication}
Recall that matrix addition is defined so that the representation of
the sum of two linear transformations is the matrix sum of the representatives.
\Sage{} can illustrate.
\begin{sagecommandline}
sage: M = matrix(QQ, [[1, 2], [3, 4]])
sage: m = linear_transformation(QQ^2, QQ^2, M, side='right')
sage: N = matrix(QQ, [[5, -1], [0, 7]])
sage: n = linear_transformation(QQ^2, QQ^2, N, side='right')
sage: m.matrix(side='right')
sage: n.matrix(side='right')
sage: (m+n).matrix(side='right')
\end{sagecommandline}
The parentheses in the final line are there because
if we enter \inlinecode{m+n.matrix(side='right')} then \Sage{} tries to combine
the linear map~\inlinecode{m} 
with the matrix \inlinecode{n.matrix(side='right')}.

Similarly, scalar multiplication of a linear map is reflected in 
the scalar multiplcation of the matrix.
\begin{sagecommandline}
sage: M = matrix(QQ, [[1, 2], [3, 4]])
sage: m = linear_transformation(QQ^2, QQ^2, M, side='right')
sage: (3*m).matrix(side='right')
sage: (m*3).matrix(side='right')
\end{sagecommandline}



\subsection{Composition}
The composition of linear maps gives rise to matrix multiplication.
\Sage{} uses the \inlinecode{*}~symbol to denote composition of linear maps.
\begin{sagecommandline}
sage: M = matrix(QQ, [[1, 2], [3, 4]])
sage: m = linear_transformation(QQ^2, QQ^2, M, side='right')
sage: N = matrix(QQ, [[5, -1], [0, 7]])
sage: n = linear_transformation(QQ^2, QQ^2, N, side='right')
sage: (m*n).matrix(side='right')
\end{sagecommandline}

As the book emphasizes, 
to represent linear map composition, use
matrix multiplication.
\begin{sagecommandline}
sage: M*N
\end{sagecommandline}




\endinput


TODO:
